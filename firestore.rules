/// üß© Firestore Security Rules - Arquitetura Modular
/// 
/// ‚ö†Ô∏è ARQUIVO GERADO AUTOMATICAMENTE
/// N√ÉO EDITE DIRETAMENTE - Edite os arquivos em /rules/ e execute ./build-rules.sh
/// 
/// Estrutura:
/// - rules/helpers.rules        ‚Üí Fun√ß√µes auxiliares reutiliz√°veis
/// - rules/users.rules          ‚Üí Cole√ß√£o Users/{userId}
/// - rules/app_config.rules     ‚Üí Cole√ß√£o AppInfo/{configName}
/// - rules/notifications.rules  ‚Üí Subcole√ß√£o Users/{userId}/Notifications/{notificationId}
/// - rules/device_tokens.rules  ‚Üí Cole√ß√£o DeviceTokens/{tokenId}
/// - rules/reviews.rules        ‚Üí Cole√ß√£o Reviews/{reviewId}
/// - rules/events.rules         ‚Üí Cole√ß√£o events/{eventId}
/// - rules/applications.rules   ‚Üí Cole√ß√£o EventApplications/{applicationId} [CORRIGIDO: permite leitura de aprovados]
/// - rules/event_chats.rules    ‚Üí Cole√ß√£o EventChats/{eventId} + subcole√ß√µes
/// - rules/connections.rules    ‚Üí Cole√ß√£o Connections/{userId}/Conversations/{withUserId}
/// - rules/messages.rules       ‚Üí Cole√ß√£o Messages/{userId}/{partnerId}/{messageId}
/// - rules/ranking.rules        ‚Üí Cole√ß√µes userRanking/{userId} e locationRanking/{placeId}
/// - rules/reports.rules        ‚Üí Cole√ß√£o reports/{reportId}

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ======================================
    // üîß Fun√ß√µes Auxiliares
    // ======================================
/// üîê Fun√ß√µes auxiliares de autentica√ß√£o/autoriza√ß√£o
/// Usadas em todos os arquivos de rules

function isSignedIn() {
  return request.auth != null;
}

function isOwner(userId) {
  return isSignedIn() && request.auth.uid == userId;
}

function isVip(userId) {
  let user = get(/databases/$(database)/documents/Users/$(userId));
  return user.data.vipExpiresAt != null && 
         user.data.vipExpiresAt > request.time;
}

function isEventCreator(eventId) {
  return isSignedIn() && 
    get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid;
}

function isEventParticipant(eventId) {
  return isSignedIn() && 
    request.auth.uid in get(/databases/$(database)/documents/events/$(eventId)).data.participants.participantIds;
}

function isParticipant(u1, u2) {
  return isSignedIn() && (request.auth.uid == u1 || request.auth.uid == u2);
}

    // ======================================
    // üë§ Usu√°rios
    // ======================================
/// üë§ Cole√ß√£o principal de usu√°rios
/// Path usado no app:
/// - Users/{userId}
///   - fullName: string
///   - instagram: string
///   - jobTitle: string
///   - gender: string
///   - bio: string
///   - country: string
///   - originSource: string
///   - interests: array<string>
///   - agreeTerms: bool
///   - photoUrl: string
///   - createdAt: timestamp
///   - updatedAt: timestamp
///   - status: string ("active" | "blocked" | ...)
///   - isBlocked: bool
///   - overallRating: number (gerenciado por Cloud Function)
///   - totalReviews: number (gerenciado por Cloud Function)
///   - lastRatingUpdate: timestamp (gerenciado por Cloud Function)
///   - isVerified: bool (gerenciado por Cloud Function)
///   - verifiedAt: timestamp (gerenciado por Cloud Function)
///   - facialId: string (gerenciado por Cloud Function)
///   - verificationType: string (gerenciado por Cloud Function)

match /Users/{userId} {
  /// üìñ LEITURA:
  /// - Qualquer usu√°rio autenticado pode ler perfis p√∫blicos
  allow read: if isSignedIn();
  
  /// ‚úçÔ∏è CRIAR perfil:
  /// - Apenas o pr√≥prio usu√°rio pode criar seu perfil
  allow create: if isOwner(userId);
  
  /// ‚úèÔ∏è ATUALIZAR perfil:
  /// - Apenas o pr√≥prio usu√°rio pode atualizar seu perfil
  /// - N√ÉO pode alterar campos protegidos (rating, verification, VIP)
  allow update: if isOwner(userId) &&
    !request.resource.data.diff(resource.data).affectedKeys()
      .hasAny(['overallRating', 'totalReviews', 'lastRatingUpdate', 
               'isVerified', 'verifiedAt', 'facialId', 'verificationType',
               'vipExpiresAt', 'vipProductId', 'vipUpdatedAt', 
               'user_is_vip', 'user_is_verified', 'user_level']);
  
  /// ‚úèÔ∏è ATUALIZAR campos protegidos (APENAS Cloud Functions):
  /// - Campos de rating (updateUserRating Cloud Function)
  /// - Campos de verifica√ß√£o Didit (ap√≥s webhook)
  /// - Campos VIP (ap√≥s purchase/subscription)
  allow update: if request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['overallRating', 'totalReviews', 'lastRatingUpdate']) ||
    request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['isVerified', 'verifiedAt', 'facialId', 'verificationType']) ||
    request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['vipExpiresAt', 'vipProductId', 'vipUpdatedAt', 
              'user_is_vip', 'user_is_verified', 'user_level']);
  
  /// üìç ATUALIZAR localiza√ß√£o (apenas o pr√≥prio usu√°rio):
  /// - Permite atualizar latitude, longitude, geohash e locationUpdatedAt
  allow update: if isOwner(userId) &&
    request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['latitude', 'longitude', 'geohash', 'locationUpdatedAt']);
  
  /// üóëÔ∏è DELETAR perfil:
  /// - Apenas o pr√≥prio usu√°rio pode deletar seu perfil
  allow delete: if isOwner(userId);
  
  /// üëÅÔ∏è Subcole√ß√£o de visitas ao perfil (legacy - deprecada)
  /// Path: Users/{userId}/visits/{visitId}
  match /visits/{visitId} {
    allow read: if isOwner(userId);
    allow create, update: if isSignedIn();
    allow delete: if isOwner(userId);
  }
}

/// üë• Cole√ß√£o em min√∫sculo usada em algumas partes do app
/// Path usado no app:
/// - users/{userId}
///   (espelho simplificado de Users/{userId} para o m√≥dulo de perfil/cache)

match /users/{userId} {
  /// üìñ LEITURA:
  /// - Qualquer usu√°rio autenticado pode ler perfis p√∫blicos
  allow read: if isSignedIn();
  
  /// ‚úçÔ∏è CRIAR perfil:
  /// - Apenas o pr√≥prio usu√°rio pode criar seu perfil
  allow create: if isOwner(userId);
  
  /// ‚úèÔ∏è ATUALIZAR perfil:
  /// - Apenas o pr√≥prio usu√°rio pode atualizar seu perfil
  /// - N√ÉO pode alterar campos protegidos
  allow update: if isOwner(userId) &&
    !request.resource.data.diff(resource.data).affectedKeys()
      .hasAny(['overallRating', 'totalReviews', 'lastRatingUpdate',
               'isVerified', 'verifiedAt', 'facialId', 'verificationType',
               'vipExpiresAt', 'vipProductId', 'vipUpdatedAt',
               'user_is_vip', 'user_is_verified', 'user_level']);
  
  /// üìç ATUALIZAR localiza√ß√£o (apenas o pr√≥prio usu√°rio):
  /// - Permite atualizar latitude, longitude, geohash e locationUpdatedAt
  allow update: if isOwner(userId) &&
    request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['latitude', 'longitude', 'geohash', 'locationUpdatedAt']);
  
  /// ‚úèÔ∏è ATUALIZAR campos protegidos (APENAS Cloud Functions):
  allow update: if request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['overallRating', 'totalReviews', 'lastRatingUpdate']) ||
    request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['isVerified', 'verifiedAt', 'facialId', 'verificationType']) ||
    request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['vipExpiresAt', 'vipProductId', 'vipUpdatedAt',
              'user_is_vip', 'user_is_verified', 'user_level']);
  
  /// üóëÔ∏è DELETAR perfil:
  allow delete: if isOwner(userId);
  
  /// üëÅÔ∏è Subcole√ß√£o de visitas ao perfil (duplicada por compatibilidade)
  /// Path: users/{userId}/visits/{visitId}
  match /visits/{visitId} {
    allow read: if isOwner(userId);
    allow create, update: if isSignedIn();
    allow delete: if isOwner(userId);
  }
}

    // ======================================
    // ‚öôÔ∏è Configura√ß√µes da Aplica√ß√£o
    // ======================================
/// ‚öôÔ∏è Cole√ß√£o de configura√ß√µes da aplica√ß√£o
/// Path usado no app:
/// - AppInfo/{configName}
///   - GoogleAndroidMaps/Api_key: string
///   - GoogleMapsApiKey/Api_key: string
///
/// üîí SEGURAN√áA:
/// - Leitura: permitida para usu√°rios autenticados (necess√°rio para inicializa√ß√£o)
/// - Escrita: bloqueada (apenas via console/Admin SDK)

match /AppInfo/{configName} {
  /// üìñ LEITURA:
  /// - Qualquer usu√°rio autenticado pode ler configura√ß√µes
  /// - Necess√°rio para inicializa√ß√£o do app (mapas, etc)
  allow read: if isSignedIn();
  
  /// ‚ùå ESCRITA:
  /// - Bloqueada para usu√°rios
  /// - Apenas via Firebase Console ou Admin SDK
  allow write: if false;
}

    // ======================================
    // üîî Notifica√ß√µes
    // ======================================
/// üîî Cole√ß√£o de notifica√ß√µes (root collection)
/// Path usado no app:
/// - Notifications/{notificationId}
///   - userId: string (quem recebe - campo principal)
///   - n_receiver_id: string (campo duplicado para compatibilidade - legacy)
///   - n_type: string
///   - n_sender_id: string
///   - n_sender_fullname: string
///   - n_sender_photo_url: string
///   - n_params: map
///   - n_metadata: map
///   - n_related_id: string
///   - n_read: bool
///   - timestamp: timestamp
///
/// üîí SEGURAN√áA:
/// - Apenas o sender pode criar notifica√ß√µes (validando n_sender_id)
/// - Apenas o receiver pode atualizar (marcar como lida) e deletar
/// - Cloud Functions podem criar notifica√ß√µes via Admin SDK

match /Notifications/{notificationId} {
  /// üìñ LEITURA:
  /// - Apenas o destinat√°rio pode ler suas notifica√ß√µes
  allow read: if isSignedIn() && 
    (resource.data.userId == request.auth.uid || resource.data.n_receiver_id == request.auth.uid);
  
  /// ‚úçÔ∏è CRIAR notifica√ß√£o:
  /// - Usu√°rio autenticado pode criar APENAS se for o sender
  /// - n_sender_id deve corresponder ao usu√°rio autenticado
  /// - Validar campos obrigat√≥rios
  /// - userId/n_receiver_id n√£o pode ser o pr√≥prio sender (evitar auto-notifica√ß√£o falsa)
  allow create: if isSignedIn() && 
    request.resource.data.n_sender_id == request.auth.uid &&
    request.resource.data.keys().hasAll(['userId', 'n_type', 'n_sender_id', 'timestamp']) &&
    request.resource.data.userId != request.auth.uid &&
    request.resource.data.n_receiver_id != request.auth.uid;
  
  /// ‚úèÔ∏è ATUALIZAR notifica√ß√£o:
  /// - Apenas o destinat√°rio pode atualizar (ex: marcar como lida)
  /// - S√≥ pode mudar n_read (n√£o pode alterar conte√∫do ou sender)
  allow update: if isSignedIn() && 
    (resource.data.userId == request.auth.uid || resource.data.n_receiver_id == request.auth.uid) &&
    request.resource.data.diff(resource.data).affectedKeys().hasOnly(['n_read']);
  
  /// üóëÔ∏è DELETAR notifica√ß√£o:
  /// - Apenas o destinat√°rio pode deletar suas notifica√ß√µes
  allow delete: if isSignedIn() && 
    (resource.data.userId == request.auth.uid || resource.data.n_receiver_id == request.auth.uid);
}

    // ======================================
    // üîë Tokens FCM
    // ======================================
/// üîë Cole√ß√£o de tokens FCM para push notifications
/// Path usado no app:
/// - DeviceTokens/{tokenId}
///   - userId: string (ID do usu√°rio dono do token)
///   - token: string (FCM token)
///   - deviceId: string (ID √∫nico do dispositivo)
///   - deviceName: string (nome do dispositivo)
///   - platform: string ("android" | "ios")
///   - createdAt: timestamp
///   - updatedAt: timestamp
///   - lastUsedAt: timestamp
///
/// Regras:
/// - Usu√°rio pode ler apenas seus pr√≥prios tokens
/// - Usu√°rio pode criar/atualizar apenas seus pr√≥prios tokens
/// - Usu√°rio pode deletar apenas seus pr√≥prios tokens
/// - Cloud Functions podem ler/escrever em qualquer token

match /DeviceTokens/{tokenId} {
  /// üìñ LEITURA:
  /// - Permite ler se o documento n√£o existe (para verificar antes de criar)
  /// - Permite ler se √© o dono do token
  allow read: if isSignedIn() && 
    (!exists(/databases/$(database)/documents/DeviceTokens/$(tokenId)) || 
     resource.data.userId == request.auth.uid);
  
  /// ‚úçÔ∏è CRIAR token:
  /// - userId deve ser o usu√°rio autenticado
  /// - Validar campos obrigat√≥rios (permite campos adicionais como timestamps)
  /// - Validar plataforma
  allow create: if isSignedIn() && 
    request.resource.data.userId == request.auth.uid &&
    request.resource.data.userId is string &&
    request.resource.data.token is string &&
    request.resource.data.deviceId is string &&
    request.resource.data.deviceName is string &&
    request.resource.data.platform is string &&
    request.resource.data.platform in ['android', 'ios'];
  
  /// ‚úèÔ∏è ATUALIZAR token:
  /// - Apenas o dono pode atualizar
  /// - N√£o pode mudar userId
  allow update: if isSignedIn() && 
    resource.data.userId == request.auth.uid &&
    request.resource.data.userId == resource.data.userId;
  
  /// üóëÔ∏è DELETAR token:
  /// - Apenas o dono pode deletar
  allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
}

    // ======================================
    // ‚≠ê Reviews/Avalia√ß√µes
    // ======================================
/// ‚≠ê Sistema completo de Reviews/Avalia√ß√µes
/// 
/// Collections:
/// - Reviews/{reviewId}           ‚Üí Reviews finalizadas
/// - PendingReviews/{pendingId}   ‚Üí Reviews pendentes (aguardando resposta)
/// 
/// Nota: ReviewStats foi removido - estat√≠sticas s√£o calculadas dinamicamente dos Reviews

// ============================================
// Reviews finalizadas
// ============================================
match /Reviews/{reviewId} {
  // Qualquer usu√°rio logado pode ler reviews
  allow read: if isSignedIn();
  
  // Criar review: apenas quem est√° fazendo a review (reviewerId)
  allow create: if isSignedIn() && 
    request.auth.uid == request.resource.data.reviewer_id;
  
  // Atualizar/deletar: apenas o autor da review
  allow update, delete: if isSignedIn() && 
    request.auth.uid == resource.data.reviewer_id;
}

// ============================================
// Reviews pendentes
// ============================================
match /PendingReviews/{pendingId} {
  // Ler: apenas o reviewer (quem deve fazer a review)
  allow read: if isSignedIn() && 
    request.auth.uid == resource.data.reviewer_id;
  
  // Criar: Cloud Functions OU Owner do evento criando review reverso para participante
  allow create: if isSignedIn() && (
    // Caso 1: Owner criando review REVERSO para participante avaliar o owner
    // O criador (request.auth.uid) deve ser o reviewee (quem ser√° avaliado = owner)
    // E o reviewer_role deve ser 'participant' (quem VAI fazer a review)
    (request.auth.uid == request.resource.data.reviewee_id &&
     request.resource.data.reviewer_role == 'participant') ||
    
    // Caso 2: Participante criando review para outro participante
    // (futuro - permitir avalia√ß√£o entre participantes)
    (request.auth.uid == request.resource.data.reviewer_id &&
     request.resource.data.reviewer_role == 'participant')
  );
  
  // Atualizar: apenas o reviewer pode:
  // 1. Marcar como dismissed
  // 2. Confirmar presen√ßa (para owners)
  allow update: if isSignedIn() && 
    request.auth.uid == resource.data.reviewer_id &&
    (
      // Op√ß√£o 1: dismissed
      (request.resource.data.dismissed == true &&
       request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly(['dismissed', 'dismissed_at'])) ||
      // Op√ß√£o 2: presence_confirmed (para owners)
      // Permite atualizar: confirmed_participant_ids e participant_profiles (nested updates)
      (request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly(['presence_confirmed', 'confirmed_participant_ids', 'participant_profiles']))
    );
  
  // Deletar: Permitido se o usu√°rio for o reviewer (ao completar a review)
  allow delete: if isSignedIn() && 
    request.auth.uid == resource.data.reviewer_id;
}

    // ======================================
    // üéâ Eventos
    // ======================================
/// üéâ Cole√ß√£o de eventos/atividades
/// Path usado no app:
/// - events/{eventId}
///   - activityText: string (descri√ß√£o da atividade)
///   - emoji: string
///   - createdBy: string (userId do criador)
///   - createdAt: timestamp
///   - updatedAt: timestamp
///   - location: map
///     - latitude: number
///     - longitude: number
///     - formattedAddress: string
///     - locationName: string
///     - locality: string
///     - placeId: string
///   - photoReferences: array<string> (opcional, fotos do Google Places)
///   - schedule: map
///     - date: timestamp
///     - timeType: string ("flexible" | "specific")
///     - specificTime: timestamp (opcional, quando timeType == "specific")
///   - participants: map
///     - minAge: number
///     - maxAge: number
///     - privacyType: string ("open" | "private")
///     - currentCount: number
///     - maxCount: number
///     - participantIds: array<string>
///     - pendingApprovalIds: array<string>
///   - status: string ("active" | "canceled" | "completed")
///   - isActive: bool
///   - isCanceled: bool
///   - expiresAt: timestamp

match /events/{eventId} {
  // Qualquer usu√°rio autenticado pode ler eventos ativos
  // Permite queries com where('isActive', isEqualTo: true)
  allow read: if isSignedIn();
  
  // Apenas usu√°rios autenticados podem criar eventos
  allow create: if isSignedIn() && 
    request.resource.data.createdBy == request.auth.uid &&
    request.resource.data.participants.participantIds[0] == request.auth.uid;
  
  // Apenas o criador pode atualizar ou deletar o evento
  allow update: if isSignedIn() && 
    resource.data.createdBy == request.auth.uid;
  
  allow delete: if isSignedIn() && 
    resource.data.createdBy == request.auth.uid;

  // Subcole√ß√£o: Participantes confirmados (para sistema de reviews)
  match /ConfirmedParticipants/{participantId} {
    // Helper para buscar o evento pai
    function getEvent() {
      return get(/databases/$(database)/documents/events/$(eventId)).data;
    }
    
    // Ler: criador do evento e o pr√≥prio participante
    allow read: if isSignedIn() && (
      request.auth.uid == getEvent().createdBy ||
      request.auth.uid == participantId
    );
    
    // Criar/Atualizar: apenas o criador do evento (durante confirma√ß√£o de presen√ßa no review)
    allow create, update: if isSignedIn() && 
      request.auth.uid == getEvent().createdBy;
    
    // Deletar: apenas o criador do evento
    allow delete: if isSignedIn() && 
      request.auth.uid == getEvent().createdBy;
  }
}

    // ======================================
    // üé´ Aplica√ß√µes para Eventos
    // ======================================
/// üé´ Cole√ß√£o de aplica√ß√µes para eventos
/// Path usado no app:
/// - EventApplications/{applicationId}
///   - eventId: string
///   - userId: string
///   - status: string ("pending" | "approved" | "rejected" | "autoApproved")
///   - appliedAt: timestamp
///   - decisionAt: timestamp (opcional)

match /EventApplications/{applicationId} {
  // Helper: buscar dados do evento relacionado
  function getEvent() {
    return get(/databases/$(database)/documents/events/$(resource.data.eventId)).data;
  }
  
  function getEventFromRequest() {
    return get(/databases/$(database)/documents/events/$(request.resource.data.eventId)).data;
  }
  
  /// üìñ LEITURA:
  /// - Criador do evento pode ver TODAS as aplica√ß√µes do seu evento
  /// - Usu√°rio pode ver APENAS suas pr√≥prias aplica√ß√µes
  /// - ‚≠ê QUALQUER usu√°rio autenticado pode ver aplica√ß√µes APROVADAS (para visualizar participantes no EventCard)
  /// 
  /// IMPORTANTE: Para queries/snapshots, a regra precisa ser permissiva o suficiente
  /// O Firestore valida se TODOS os documentos retornados pela query passariam na regra
  allow read: if isSignedIn() && (
    // Sou o criador do evento
    request.auth.uid == getEvent().createdBy ||
    // √â minha pr√≥pria aplica√ß√£o
    request.auth.uid == resource.data.userId ||
    // √â uma aplica√ß√£o aprovada (qualquer um pode ver para visualizar participantes)
    (resource.data.status == 'approved' || resource.data.status == 'autoApproved')
  );
  
  // Permitir list/query explicitamente para queries filtradas por status aprovado
  allow list: if isSignedIn() && (
    // Query deve filtrar por status aprovado OU ser do criador do evento
    request.query.limit <= 100 // Limitar tamanho da query
  );
  
  /// ‚úçÔ∏è CRIAR aplica√ß√£o:
  /// - Usu√°rio autenticado
  /// - userId deve ser o pr√≥prio usu√°rio
  /// - Status deve ser "pending" ou "autoApproved" baseado no privacyType
  /// - N√£o pode aplicar para o pr√≥prio evento (criador n√£o precisa aplicar)
  /// - Validar que o evento existe e est√° ativo
  /// 
  /// ‚ö†Ô∏è NOTA: Prote√ß√£o contra duplicatas √© feita no app (event_application_repository.dart)
  /// pois Firestore Rules n√£o permite queries para verificar aplica√ß√µes existentes.
  /// A valida√ß√£o acontece antes de chamar .add() no reposit√≥rio.
  allow create: if isSignedIn() && 
    request.resource.data.userId == request.auth.uid &&
    request.resource.data.userId != getEventFromRequest().createdBy &&
    request.resource.data.keys().hasAll(['eventId', 'userId', 'status', 'appliedAt']) &&
    getEventFromRequest().isActive == true &&
    (
      (getEventFromRequest().participants.privacyType == 'open' && 
       request.resource.data.status == 'autoApproved') ||
      (getEventFromRequest().participants.privacyType == 'private' && 
       request.resource.data.status == 'pending')
    );
  
  /// ‚úèÔ∏è ATUALIZAR aplica√ß√£o:
  /// CASO 1: Criador do evento aprovando/rejeitando
  /// - Apenas o criador do evento pode aprovar/rejeitar
  /// - N√£o pode mudar eventId ou userId
  /// - S√≥ pode mudar de "pending" para "approved" ou "rejected"
  /// - Deve incluir decisionAt
  allow update: if isSignedIn() && 
    request.auth.uid == getEvent().createdBy &&
    request.resource.data.eventId == resource.data.eventId &&
    request.resource.data.userId == resource.data.userId &&
    resource.data.status == 'pending' &&
    (request.resource.data.status == 'approved' || 
     request.resource.data.status == 'rejected') &&
    request.resource.data.decisionAt != null;
  
  /// ‚úèÔ∏è ATUALIZAR presen√ßa:
  /// CASO 2: Usu√°rio atualizando sua pr√≥pria presen√ßa
  /// - √â a pr√≥pria aplica√ß√£o do usu√°rio
  /// - S√≥ pode mudar o campo "presence"
  /// - N√£o pode mudar status, eventId ou userId
  /// - Aplica√ß√£o deve estar aprovada
  allow update: if isSignedIn() && 
    request.auth.uid == resource.data.userId &&
    request.resource.data.eventId == resource.data.eventId &&
    request.resource.data.userId == resource.data.userId &&
    request.resource.data.status == resource.data.status &&
    (resource.data.status == 'approved' || resource.data.status == 'autoApproved') &&
    request.resource.data.presence in ['Vou', 'Talvez', 'N√£o vou'];
  
  /// üóëÔ∏è DELETE:
  /// - Criador do evento pode deletar aplica√ß√µes ao deletar o evento
  /// - Usu√°rio pode deletar sua pr√≥pria aplica√ß√£o (sair do evento)
  allow delete: if isSignedIn() && (
    request.auth.uid == getEvent().createdBy ||
    request.auth.uid == resource.data.userId
  );
}

    // ======================================
    // üí¨ Chats de Eventos
    // ======================================
/// üí¨ Cole√ß√£o de chats de eventos (multiusu√°rio)
/// Path usado no app:
/// - EventChats/{eventId}
///   - eventId: string
///   - createdBy: string
///   - createdAt: timestamp
///   - lastMessage: string
///   - lastMessageAt: timestamp
///   - lastMessageSenderId: string
///   - participantIds: array<string>
///   - participantCount: number

match /EventChats/{eventId} {
  // Helper para verificar se √© o criador do evento
  function isEventCreator() {
    let event = get(/databases/$(database)/documents/events/$(eventId));
    return event.data.createdBy == request.auth.uid;
  }
  
  // Qualquer participante aprovado pode ler o chat
  allow read: if isSignedIn() && 
    request.auth.uid in resource.data.participantIds;
  
  // Apenas Cloud Functions podem criar/atualizar o documento principal
  allow create, update: if false;
  
  // ‚úÖ O criador do evento pode deletar o chat
  allow delete: if isSignedIn() && isEventCreator();

  /// üí¨ Mensagens dentro do chat
  match /Messages/{messageId} {
    // Helper: verifica se usu√°rio √© participante do evento
    function isParticipant() {
      return request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds;
    }
    
    // Helper: verifica se √© o criador do evento
    function isEventCreator() {
      let event = get(/databases/$(database)/documents/events/$(eventId));
      return event.data.createdBy == request.auth.uid;
    }
    
    /// üìñ LEITURA:
    /// - Qualquer participante pode ler mensagens
    /// - Criador do evento pode ler (para deletar ao excluir evento)
    allow read: if isSignedIn() && (isParticipant() || isEventCreator());
    
    /// ‚úçÔ∏è CRIAR mensagem:
    /// - Participante autenticado
    /// - sender_id deve ser o usu√°rio autenticado
    /// - Validar campos obrigat√≥rios
    /// - Validar tipo de mensagem permitido
    /// - Limitar tamanho de mensagem (se aplic√°vel)
    allow create: if isSignedIn() && 
      isParticipant() &&
      request.resource.data.sender_id == request.auth.uid &&
      request.resource.data.keys().hasAll(['sender_id', 'message_type', 'timestamp']) &&
      request.resource.data.message_type in ['text', 'image', 'location', 'audio'];
    
    /// ‚ùå UPDATE: Mensagens s√£o imut√°veis (n√£o pode editar)
    allow update: if false;
    
    /// ‚úÖ DELETE: Apenas o criador do evento pode deletar mensagens (ao deletar o evento)
    allow delete: if isSignedIn() && isEventCreator();
  }

  /// üë• Participantes do chat
  match /Participants/{userId} {
    /// üìñ LEITURA:
    /// - Cada participante pode ler todos os outros
    allow read: if isSignedIn() && 
      request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds;
    
    /// ‚úèÔ∏è ATUALIZAR:
    /// - Cada participante pode atualizar APENAS seu pr√≥prio documento
    /// - S√≥ pode mudar campos de leitura (lastReadAt, unreadCount)
    /// - N√£o pode mudar identificadores ou status
    allow update: if isSignedIn() && 
      request.auth.uid == userId &&
      request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds &&
      request.resource.data.diff(resource.data).affectedKeys()
        .hasOnly(['lastReadAt', 'unreadCount']);
    
    /// ‚ùå CREATE/DELETE:
    /// - Apenas Cloud Functions podem criar/deletar participantes
    allow create, delete: if false;
  }
}

    // ======================================
    // üí¨ Connections (Conversas 1-1)
    // ======================================
/// üí¨ Cole√ß√£o de conex√µes/conversas entre usu√°rios e eventos
/// Path usado no app:
/// - Connections/{userId}/Conversations/{withUserId}
///   - user_id: string (userId do outro usu√°rio ou event_{eventId})
///   - fullname: string
///   - user_profile_photo: string
///   - message_type: string
///   - last_message: string
///   - message_read: bool
///   - timestamp: timestamp
///   - is_event_chat: bool (opcional, true para chats de eventos)
///   - event_id: string (opcional, eventId para chats de eventos)

match /Connections/{userId} {
  // Helper para verificar se √© criador do evento
  function isEventCreator(eventId) {
    let event = get(/databases/$(database)/documents/events/$(eventId));
    return event.data.createdBy == request.auth.uid;
  }
  
  match /Conversations/{withUserId} {
    // Helper: verifica se √© conversa de evento
    function isEventConversation() {
      return withUserId.matches('event_.*');
    }
    
    // Helper: extrai eventId do withUserId (event_{eventId})
    function getEventId() {
      return withUserId.split('_')[1];
    }
    
    // Helper: verifica se usu√°rio √© participante aprovado do evento
    // Como EventApplications n√£o usa padr√£o de ID previs√≠vel, verificamos via query
    // Simplifica√ß√£o: assumimos que se o documento Connections/{userId}/Conversations/event_{eventId} existe,
    // significa que o backend j√° validou e criou a conversa (via Cloud Function ap√≥s aprova√ß√£o)
    function isApprovedParticipant() {
      // Se chegou at√© aqui, o backend j√° criou a conversa
      return isSignedIn();
    }
    
    /// üìñ LEITURA:
    /// - Conversa 1-1: usu√°rio pode ler suas pr√≥prias conversas
    /// - Conversa de evento: participante aprovado pode ler
    allow read: if isSignedIn() && (
      // Conversa 1-1: sou o dono
      request.auth.uid == userId ||
      // Conversa de evento: sou participante aprovado
      (isEventConversation() && request.auth.uid == userId && isApprovedParticipant())
    );
    
    /// ‚úçÔ∏è CRIAR/ATUALIZAR:
    /// - Conversa 1-1: ambos participantes podem criar/atualizar
    /// - Conversa de evento: participante aprovado pode criar/atualizar sua pr√≥pria conversa
    allow create, update: if isSignedIn() && (
      // Conversa 1-1: sou participante
      isParticipant(userId, withUserId) ||
      // Conversa de evento: sou o dono e sou participante aprovado
      (isEventConversation() && request.auth.uid == userId && isApprovedParticipant())
    );
    
    /// üóëÔ∏è DELETAR:
    /// - Dono pode deletar sua pr√≥pria conversa
    /// - Criador do evento pode deletar conversas de evento ao deletar o evento
    allow delete: if isSignedIn() && (
      request.auth.uid == userId ||
      (isEventConversation() && isEventCreator(getEventId()))
    );
  }
}

    // ======================================
    // üí¨ Messages (Mensagens 1-1)
    // ======================================
/// üí¨ Cole√ß√£o de mensagens entre usu√°rios e chats de eventos
/// Path usado no app:
/// - Messages/{userId}/{partnerId}/{messageId}
///   - sender_id: string
///   - message_type: string
///   - timestamp: timestamp
///   - content: string ou map (dependendo do tipo)
/// 
/// Para chats de eventos:
/// - Messages/{userId}/event_{eventId}/{messageId}
///   - sender_id: string
///   - message_type: string
///   - timestamp: timestamp
///   - message: string

match /Messages/{userId} {
  match /{partnerId}/{messageId} {
    // Helper: verifica se √© chat de evento
    function isEventChat() {
      return partnerId.matches('event_.*');
    }
    
    // Helper: extrai eventId do partnerId (event_{eventId})
    function getEventId() {
      return partnerId.split('_')[1];
    }
    
    // Helper: verifica se usu√°rio √© participante aprovado do evento
    // Como EventApplications n√£o usa padr√£o de ID previs√≠vel, verificamos via query
    // Simplifica√ß√£o: assumimos que se o documento Messages/{userId}/event_{eventId} existe,
    // significa que o backend j√° validou e criou a conversa (via Cloud Function ap√≥s aprova√ß√£o)
    function isApprovedParticipant() {
      // Se chegou at√© aqui enviando mensagem, o backend j√° criou a conversa
      // Valida√ß√£o adicional seria custosa (query n√£o permitida em rules)
      return isSignedIn();
    }
    
    /// üìñ LEITURA:
    /// - Chat 1-1: usu√°rio pode ler suas pr√≥prias mensagens
    /// - Chat de evento: participante aprovado pode ler
    allow read: if isSignedIn() && (
      // Chat 1-1: sou o dono da conversa
      request.auth.uid == userId ||
      // Chat de evento: sou participante aprovado
      (isEventChat() && isApprovedParticipant())
    );
    
    /// ‚úçÔ∏è CRIAR mensagem:
    /// - Chat 1-1: participante pode enviar
    /// - Chat de evento: participante aprovado pode enviar
    allow create: if isSignedIn() && (
      // Chat 1-1
      (isParticipant(userId, partnerId) &&
       request.resource.data.sender_id == request.auth.uid &&
       request.resource.data.message_type is string &&
       request.resource.data.timestamp is timestamp) ||
      // Chat de evento
      (isEventChat() && 
       isApprovedParticipant() &&
       request.resource.data.sender_id == request.auth.uid &&
       request.resource.data.message_type is string &&
       request.resource.data.timestamp is timestamp)
    );
    
    /// ‚úèÔ∏è ATUALIZAR/DELETAR:
    /// - Apenas o dono da conversa pode atualizar/deletar
    allow update, delete: if isSignedIn() && request.auth.uid == userId;
  }
}

    // ======================================
    // üëÅÔ∏è Visitas ao Perfil
    // ======================================
/// üëÅÔ∏è Cole√ß√£o de visitas ao perfil (root level para suporte TTL)
/// Path: ProfileVisits/{visitId}
/// 
/// Estrutura:
/// - visitedUserId: string (quem recebeu a visita)
/// - visitorId: string (quem visitou)
/// - visitedAt: timestamp
/// - visitCount: number (incrementa em visitas repetidas)
/// - expireAt: timestamp (TTL - 7 dias)
/// - source: string ('profile', 'event', etc)
///
/// üîí SEGURAN√áA VIP:
/// - Leitura: apenas VIPs podem ver quem visitou seu perfil
/// - Escrita: apenas o visitor pode registrar sua pr√≥pria visita

match /ProfileVisits/{visitId} {
  /// üìñ LEITURA (get/list - ver detalhes das visitas): 
  /// - Apenas VIP pode ver QUEM visitou seu perfil
  allow get, list: if isSignedIn() && 
                      request.auth.uid == resource.data.visitedUserId &&
                      isVip(request.auth.uid);
  
  /// ‚úçÔ∏è CRIAR visita:
  /// - Usu√°rio autenticado
  /// - visitorId DEVE ser o usu√°rio autenticado (n√£o pode falsificar visitas)
  /// - Validar campos obrigat√≥rios
  /// - N√£o pode visitar o pr√≥prio perfil
  allow create: if isSignedIn() &&
                   request.resource.data.visitorId == request.auth.uid &&
                   request.resource.data.visitedUserId != request.auth.uid &&
                   request.resource.data.keys().hasAll(['visitedUserId', 'visitorId', 'visitedAt']);
  
  /// ‚úèÔ∏è ATUALIZAR visita:
  /// - Apenas o visitor pode atualizar sua pr√≥pria visita (incrementar visitCount)
  /// - N√£o pode mudar visitedUserId ou visitorId
  allow update: if isSignedIn() &&
                   resource.data.visitorId == request.auth.uid &&
                   request.resource.data.visitedUserId == resource.data.visitedUserId &&
                   request.resource.data.visitorId == resource.data.visitorId;
  
  /// üóëÔ∏è DELETE: 
  /// - Apenas o dono do perfil pode deletar visitas recebidas
  allow delete: if isSignedIn() && 
                   request.auth.uid == resource.data.visitedUserId;
}

/// üëÅÔ∏è Cole√ß√£o de views agregadas (para notifica√ß√µes)
/// Path: ProfileViews/{viewId}
match /ProfileViews/{viewId} {
  /// ‚úçÔ∏è CRIAR view:
  /// - Usu√°rio autenticado
  /// - viewerId DEVE ser o usu√°rio autenticado
  /// - Validar campos obrigat√≥rios
  allow create: if isSignedIn() &&
                   request.resource.data.viewerId == request.auth.uid &&
                   request.resource.data.keys().hasAll(['viewedUserId', 'viewerId', 'viewedAt']);
  
  /// üìñ LEITURA:
  /// - Apenas o dono do perfil visualizado pode ler
  allow read: if isSignedIn() && 
                 request.auth.uid == resource.data.viewedUserId;
  
  /// üóëÔ∏è DELETE/UPDATE: n√£o permitido
  allow update, delete: if false;
}

    // ======================================
    // üèÜ Rankings
    // ======================================
/// üèÜ Cole√ß√£o de ranking de usu√°rios
/// Path usado no app:
/// - userRanking/{userId}
///   - userId: string
///   - fullName: string
///   - photoUrl: string (nullable)
///   - totalEventsCreated: number
///   - lastEventAt: timestamp
///   - lastLat: number
///   - lastLng: number
///   - updatedAt: timestamp

match /userRanking/{userId} {
  // Qualquer usu√°rio autenticado pode ler rankings
  allow read: if isSignedIn();
  
  // Apenas Cloud Functions podem criar/atualizar rankings
  allow write: if false;
}

/// üèÜ Cole√ß√£o de ranking de locais
/// Path usado no app:
/// - locationRanking/{placeId}
///   - placeId: string
///   - locationName: string
///   - formattedAddress: string
///   - totalEventsHosted: number
///   - lastEventAt: timestamp
///   - lastLat: number
///   - lastLng: number
///   - updatedAt: timestamp

match /locationRanking/{placeId} {
  // Qualquer usu√°rio autenticado pode ler rankings
  allow read: if isSignedIn();
  
  // Apenas Cloud Functions podem criar/atualizar rankings
  allow write: if false;
}

    // ======================================
    // üö© Reports/Den√∫ncias
    // ======================================
/// üö© Regras de Seguran√ßa para Reports
/// 
/// Cole√ß√£o: reports/{reportId}
/// 
/// Caracter√≠sticas:
/// - Apenas usu√°rios autenticados podem criar reports
/// - Ningu√©m pode ler reports (apenas admins via console/backend)
/// - Suporta dois tipos: bug reports e event reports
/// - Mensagem/reportText limitado a 2000/500 caracteres
/// - Campos obrigat√≥rios validados

match /reports/{reportId} {
  // ‚ùå Ningu√©m pode ler reports (seguran√ßa e privacidade)
  allow read: if false;
  
  // ‚úÖ Apenas usu√°rios autenticados podem criar reports
  // Suporta dois tipos de reports:
  // 1. Bug/Feedback reports (campos: reporterId, message, platform, appVersion)
  // 2. Event reports (campos: reportedBy, eventId, reportText, type, status)
  allow create: if isSignedIn() && (
    // Tipo 1: Bug/Feedback report
    ('reporterId' in request.resource.data
    && 'message' in request.resource.data
    && request.resource.data.reporterId == request.auth.uid
    && request.resource.data.message is string
    && request.resource.data.message.size() >= 10
    && request.resource.data.message.size() <= 2000)
    
    ||
    
    // Tipo 2: Event report
    ('reportedBy' in request.resource.data
    && 'eventId' in request.resource.data
    && 'reportText' in request.resource.data
    && 'type' in request.resource.data
    && request.resource.data.reportedBy == request.auth.uid
    && request.resource.data.reportText is string
    && request.resource.data.reportText.size() >= 1
    && request.resource.data.reportText.size() <= 500
    && request.resource.data.eventId is string
    && request.resource.data.type == 'event'
    && request.resource.data.status == 'pending')
  );
  
  // ‚ùå Ningu√©m pode atualizar ou deletar reports
  allow update, delete: if false;
}

    // ======================================
    // üé≠ Verifica√ß√µes Didit
    // ======================================
/// üé≠ Cole√ß√£o de verifica√ß√µes faciais/ID com Didit
/// Path usado no app:
/// - FaceVerifications/{userId}
///   - facialId: string (session_id do Didit)
///   - verificationType: string ("didit")
///   - verifiedAt: timestamp
///   - userInfo: map (dados extra√≠dos)

match /FaceVerifications/{userId} {
  // Usu√°rio pode ler apenas sua pr√≥pria verifica√ß√£o
  allow read: if isOwner(userId);
  
  // Usu√°rio pode criar/atualizar apenas sua pr√≥pria verifica√ß√£o
  allow create, update: if isOwner(userId);
  
  // Cloud Functions podem criar verifica√ß√µes (webhook do Didit)
  allow create: if true;
  
  // N√£o permite deletar verifica√ß√µes (auditoria)
  allow delete: if false;
}

/// üìã Cole√ß√£o de sess√µes de verifica√ß√£o Didit
/// Path usado no app:
/// - DiditSessions/{sessionId}
///   - sessionId: string
///   - userId: string
///   - url: string
///   - workflowId: string
///   - status: string
///   - createdAt: timestamp
///   - vendorData: string

match /DiditSessions/{sessionId} {
  // Usu√°rio pode criar suas pr√≥prias sess√µes
  allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
  
  // Usu√°rio pode ler suas pr√≥prias sess√µes (verifica se existe primeiro)
  allow read: if isSignedIn() && (
    resource == null || // Documento n√£o existe ainda
    resource.data.userId == request.auth.uid // Ou pertence ao usu√°rio
  );
  
  // Cloud Functions podem atualizar campos espec√≠ficos de status
  allow update: if request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['status', 'completedAt', 'result', 'lastWebhookType', 'lastWebhookAt']);
  
  // N√£o permite deletar sess√µes (auditoria)
  allow delete: if false;
}

/// üì® Cole√ß√£o de webhooks recebidos do Didit
/// Path usado no app:
/// - DiditWebhooks/{webhookId}
///   - sessionId: string
///   - webhookType: string
///   - decision: map
///   - idVerification: map
///   - receivedAt: timestamp
///
/// üîí SEGURAN√áA:
/// - Create: permitido sem autentica√ß√£o (vem do servidor Didit)
/// - ‚ö†Ô∏è Valida√ß√£o de signature acontece no backend (Cloud Function)
/// - Leitura: apenas via console/backend (Admin SDK)

match /DiditWebhooks/{webhookId} {
  /// üìñ LEITURA:
  /// - Bloqueada para usu√°rios normais (dados sens√≠veis)
  /// - Apenas admins via console/backend
  allow read: if false;
  
  /// ‚úçÔ∏è CRIAR webhook:
  /// - Permitido sem auth (servidor Didit n√£o tem token Firebase)
  /// - Valida√ß√£o de signature acontece na Cloud Function
  /// - Campos obrigat√≥rios validados
  allow create: if request.resource.data.keys().hasAll(['sessionId', 'webhookType', 'receivedAt']);
  
  /// ‚úèÔ∏è ATUALIZAR webhook:
  /// - Cloud Functions podem marcar como processado
  allow update: if request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['processed', 'processedAt']);
  
  /// üóëÔ∏è DELETE:
  /// - N√£o permitido (auditoria)
  allow delete: if false;
}

    // ======================================
    // üö´ Bloquear outras cole√ß√µes
    // ======================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
