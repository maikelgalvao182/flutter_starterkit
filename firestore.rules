/// üß© Firestore Security Rules - Arquitetura Modular
/// 
/// ‚ö†Ô∏è ARQUIVO GERADO AUTOMATICAMENTE
/// N√ÉO EDITE DIRETAMENTE - Edite os arquivos em /rules/ e execute ./build-rules.sh
/// 
/// Estrutura:
/// - rules/helpers.rules        ‚Üí Fun√ß√µes auxiliares reutiliz√°veis
/// - rules/users.rules          ‚Üí Cole√ß√£o Users/{userId}
/// - rules/app_config.rules     ‚Üí Cole√ß√£o AppInfo/{configName}
/// - rules/notifications.rules  ‚Üí Subcole√ß√£o Users/{userId}/Notifications/{notificationId}
/// - rules/reviews.rules        ‚Üí Cole√ß√£o Reviews/{reviewId}
/// - rules/events.rules         ‚Üí Cole√ß√£o events/{eventId}
/// - rules/applications.rules   ‚Üí Cole√ß√£o EventApplications/{applicationId} [CORRIGIDO: permite leitura de aprovados]
/// - rules/event_chats.rules    ‚Üí Cole√ß√£o EventChats/{eventId} + subcole√ß√µes
/// - rules/connections.rules    ‚Üí Cole√ß√£o Connections/{userId}/Conversations/{withUserId}
/// - rules/messages.rules       ‚Üí Cole√ß√£o Messages/{userId}/{partnerId}/{messageId}

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ======================================
    // üîß Fun√ß√µes Auxiliares
    // ======================================
/// üîê Fun√ß√µes auxiliares de autentica√ß√£o/autoriza√ß√£o
/// Usadas em todos os arquivos de rules

function isSignedIn() {
  return request.auth != null;
}

function isOwner(userId) {
  return isSignedIn() && request.auth.uid == userId;
}

function isEventCreator(eventId) {
  return isSignedIn() && 
    get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid;
}

function isEventParticipant(eventId) {
  return isSignedIn() && 
    request.auth.uid in get(/databases/$(database)/documents/events/$(eventId)).data.participants.participantIds;
}

    // ======================================
    // üë§ Usu√°rios
    // ======================================
/// üë§ Cole√ß√£o principal de usu√°rios
/// Path usado no app:
/// - Users/{userId}
///   - fullName: string
///   - instagram: string
///   - jobTitle: string
///   - gender: string
///   - bio: string
///   - country: string
///   - originSource: string
///   - interests: array<string>
///   - agreeTerms: bool
///   - photoUrl: string
///   - createdAt: timestamp
///   - updatedAt: timestamp
///   - status: string ("active" | "blocked" | ...)
///   - isBlocked: bool

match /Users/{userId} {
  allow read: if isSignedIn();
  allow create, update, delete: if isOwner(userId);
}

/// üë• Cole√ß√£o em min√∫sculo usada em algumas partes do app
/// Path usado no app:
/// - users/{userId}
///   (espelho simplificado de Users/{userId} para o m√≥dulo de perfil/cache)

match /users/{userId} {
  allow read: if isSignedIn();
  allow create, update, delete: if isOwner(userId);
}

    // ======================================
    // ‚öôÔ∏è Configura√ß√µes da Aplica√ß√£o
    // ======================================
/// ‚öôÔ∏è Cole√ß√£o de configura√ß√µes da aplica√ß√£o
/// Path usado no app:
/// - AppInfo/{configName}
///   - GoogleAndroidMaps/Api_key: string
///   - GoogleMapsApiKey/Api_key: string

match /AppInfo/{configName} {
  allow read: if isSignedIn();
  allow write: if false; // Apenas leitura para usu√°rios
}

    // ======================================
    // üîî Notifica√ß√µes
    // ======================================
/// üîî Cole√ß√£o de notifica√ß√µes
/// Path usado no app:
/// - Users/{userId}/Notifications/{notificationId}
///   - n_type: string
///   - n_sender_id: string
///   - n_sender_fullname: string
///   - n_sender_photo_url: string
///   - n_params: map
///   - n_metadata: map
///   - n_related_id: string
///   - n_read: bool
///   - timestamp: timestamp

match /Users/{userId}/Notifications/{notificationId} {
  allow read, delete: if isOwner(userId);
  allow create, update: if isSignedIn(); // Qualquer usu√°rio logado pode criar notifica√ß√µes para outros
}

    // ======================================
    // ‚≠ê Reviews/Avalia√ß√µes
    // ======================================
/// ‚≠ê Cole√ß√£o de reviews/avalia√ß√µes
/// Path usado no app:
/// - Reviews/{reviewId}
///   - revieweeId: string (usu√°rio que recebeu a review)
///   - reviewerId: string (usu√°rio que fez a review)
///   - rating: number
///   - comment: string
///   - createdAt: timestamp

match /Reviews/{reviewId} {
  allow read: if isSignedIn(); // Qualquer usu√°rio logado pode ler reviews
  allow create: if isSignedIn(); // Qualquer usu√°rio logado pode criar reviews
  allow update, delete: if isSignedIn() && 
    request.auth.uid == resource.data.reviewerId; // Apenas o autor pode editar/deletar
}

    // ======================================
    // üéâ Eventos
    // ======================================
/// üéâ Cole√ß√£o de eventos/atividades
/// Path usado no app:
/// - events/{eventId}
///   - activityText: string (descri√ß√£o da atividade)
///   - emoji: string
///   - createdBy: string (userId do criador)
///   - createdAt: timestamp
///   - updatedAt: timestamp
///   - location: map
///     - latitude: number
///     - longitude: number
///     - formattedAddress: string
///     - locationName: string
///     - locality: string
///     - placeId: string
///   - photoReferences: array<string> (opcional, fotos do Google Places)
///   - schedule: map
///     - date: timestamp
///     - timeType: string ("flexible" | "specific")
///     - specificTime: timestamp (opcional, quando timeType == "specific")
///   - participants: map
///     - minAge: number
///     - maxAge: number
///     - privacyType: string ("open" | "private")
///     - currentCount: number
///     - maxCount: number
///     - participantIds: array<string>
///     - pendingApprovalIds: array<string>
///   - status: string ("active" | "canceled" | "completed")
///   - isActive: bool
///   - isCanceled: bool
///   - expiresAt: timestamp

match /events/{eventId} {
  // Qualquer usu√°rio autenticado pode ler eventos ativos
  allow read: if isSignedIn() && resource.data.isActive == true;
  
  // Apenas usu√°rios autenticados podem criar eventos
  allow create: if isSignedIn() && 
    request.resource.data.createdBy == request.auth.uid &&
    request.resource.data.participants.participantIds[0] == request.auth.uid;
  
  // Apenas o criador pode atualizar ou deletar o evento
  allow update: if isSignedIn() && 
    resource.data.createdBy == request.auth.uid;
  
  allow delete: if isSignedIn() && 
    resource.data.createdBy == request.auth.uid;
}

    // ======================================
    // üé´ Aplica√ß√µes para Eventos
    // ======================================
/// üé´ Cole√ß√£o de aplica√ß√µes para eventos
/// Path usado no app:
/// - EventApplications/{applicationId}
///   - eventId: string
///   - userId: string
///   - status: string ("pending" | "approved" | "rejected" | "autoApproved")
///   - appliedAt: timestamp
///   - decisionAt: timestamp (opcional)

match /EventApplications/{applicationId} {
  // Helper: buscar dados do evento relacionado
  function getEvent() {
    return get(/databases/$(database)/documents/events/$(resource.data.eventId)).data;
  }
  
  function getEventFromRequest() {
    return get(/databases/$(database)/documents/events/$(request.resource.data.eventId)).data;
  }
  
  /// üìñ LEITURA:
  /// - Criador do evento pode ver TODAS as aplica√ß√µes do seu evento
  /// - Usu√°rio pode ver APENAS suas pr√≥prias aplica√ß√µes
  /// - ‚≠ê QUALQUER usu√°rio autenticado pode ver aplica√ß√µes APROVADAS (para visualizar participantes no EventCard)
  allow read: if isSignedIn() && (
    // Sou o criador do evento
    request.auth.uid == getEvent().createdBy ||
    // √â minha pr√≥pria aplica√ß√£o
    request.auth.uid == resource.data.userId ||
    // √â uma aplica√ß√£o aprovada (qualquer um pode ver para visualizar participantes)
    (resource.data.status == 'approved' || resource.data.status == 'autoApproved')
  );
  
  /// ‚úçÔ∏è CRIAR aplica√ß√£o:
  /// - Usu√°rio autenticado
  /// - userId deve ser o pr√≥prio usu√°rio
  /// - Status deve ser "pending" ou "autoApproved" baseado no privacyType
  allow create: if isSignedIn() && 
    request.resource.data.userId == request.auth.uid &&
    request.resource.data.keys().hasAll(['eventId', 'userId', 'status', 'appliedAt']) &&
    (
      (getEventFromRequest().participants.privacyType == 'open' && 
       request.resource.data.status == 'autoApproved') ||
      (getEventFromRequest().participants.privacyType == 'private' && 
       request.resource.data.status == 'pending')
    );
  
  /// ‚úèÔ∏è ATUALIZAR aplica√ß√£o:
  /// - Apenas o criador do evento pode aprovar/rejeitar
  /// - N√£o pode mudar eventId ou userId
  /// - S√≥ pode mudar de "pending" para "approved" ou "rejected"
  /// - Deve incluir decisionAt
  allow update: if isSignedIn() && 
    request.auth.uid == getEvent().createdBy &&
    request.resource.data.eventId == resource.data.eventId &&
    request.resource.data.userId == resource.data.userId &&
    resource.data.status == 'pending' &&
    (request.resource.data.status == 'approved' || 
     request.resource.data.status == 'rejected') &&
    request.resource.data.decisionAt != null;
  
  /// üóëÔ∏è DELETE: n√£o permitido
  allow delete: if false;
}

    // ======================================
    // üí¨ Chats de Eventos
    // ======================================
/// üí¨ Cole√ß√£o de chats de eventos (multiusu√°rio)
/// Path usado no app:
/// - EventChats/{eventId}
///   - eventId: string
///   - createdBy: string
///   - createdAt: timestamp
///   - lastMessage: string
///   - lastMessageAt: timestamp
///   - lastMessageSenderId: string
///   - participantIds: array<string>
///   - participantCount: number

match /EventChats/{eventId} {
  // Qualquer participante aprovado pode ler o chat
  allow read: if isSignedIn() && 
    request.auth.uid in resource.data.participantIds;
  
  // Apenas Cloud Functions podem criar/atualizar o documento principal
  allow write: if false;

  /// üí¨ Mensagens dentro do chat
  match /Messages/{messageId} {
    // Qualquer participante pode ler mensagens
    allow read: if isSignedIn() && 
      request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds;
    
    // Qualquer participante pode enviar mensagens
    allow create: if isSignedIn() && 
      request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds &&
      request.resource.data.senderId == request.auth.uid;
    
    // N√£o pode editar/deletar mensagens
    allow update, delete: if false;
  }

  /// üë• Participantes do chat
  match /Participants/{userId} {
    // Cada participante pode ler todos os outros
    allow read: if isSignedIn() && 
      request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds;
    
    // Cada participante pode atualizar apenas seu pr√≥prio documento (lastReadAt, unreadCount)
    allow update: if isSignedIn() && 
      request.auth.uid == userId &&
      request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds;
    
    // Apenas Cloud Functions podem criar/deletar participantes
    allow create, delete: if false;
  }
}

    // ======================================
    // üí¨ Connections (Conversas 1-1)
    // ======================================
/// üí¨ Cole√ß√£o de conex√µes/conversas entre usu√°rios e eventos
/// Path usado no app:
/// - Connections/{userId}/Conversations/{withUserId}
///   - user_id: string (userId do outro usu√°rio ou event_{eventId})
///   - user_fullname: string
///   - user_profile_photo: string
///   - message_type: string
///   - last_message: string
///   - message_read: bool
///   - timestamp: timestamp
///   - is_event_chat: bool (opcional, true para chats de eventos)
///   - event_id: string (opcional, eventId para chats de eventos)

match /Connections/{userId} {
  match /Conversations/{withUserId} {
    // Helper: verifica se √© conversa de evento
    function isEventConversation() {
      return withUserId.matches('event_.*');
    }
    
    // Helper: extrai eventId do withUserId (event_{eventId})
    function getEventId() {
      return withUserId.split('_')[1];
    }
    
    // Helper: verifica se usu√°rio √© participante aprovado do evento
    // Como EventApplications n√£o usa padr√£o de ID previs√≠vel, verificamos via query
    // Simplifica√ß√£o: assumimos que se o documento Connections/{userId}/Conversations/event_{eventId} existe,
    // significa que o backend j√° validou e criou a conversa (via Cloud Function ap√≥s aprova√ß√£o)
    function isApprovedParticipant() {
      // Se chegou at√© aqui, o backend j√° criou a conversa
      return isSignedIn();
    }
    
    /// üìñ LEITURA:
    /// - Conversa 1-1: usu√°rio pode ler suas pr√≥prias conversas
    /// - Conversa de evento: participante aprovado pode ler
    allow read: if isSignedIn() && (
      // Conversa 1-1: sou o dono
      request.auth.uid == userId ||
      // Conversa de evento: sou participante aprovado
      (isEventConversation() && request.auth.uid == userId && isApprovedParticipant())
    );
    
    /// ‚úçÔ∏è CRIAR/ATUALIZAR:
    /// - Conversa 1-1: ambos participantes podem criar/atualizar
    /// - Conversa de evento: participante aprovado pode criar/atualizar sua pr√≥pria conversa
    allow create, update: if isSignedIn() && (
      // Conversa 1-1: sou participante
      isParticipant(userId, withUserId) ||
      // Conversa de evento: sou o dono e sou participante aprovado
      (isEventConversation() && request.auth.uid == userId && isApprovedParticipant())
    );
    
    /// üóëÔ∏è DELETAR:
    /// - Apenas o dono pode deletar sua conversa
    allow delete: if isSignedIn() && request.auth.uid == userId;
  }
}

    // ======================================
    // üí¨ Messages (Mensagens 1-1)
    // ======================================
/// üí¨ Cole√ß√£o de mensagens entre usu√°rios e chats de eventos
/// Path usado no app:
/// - Messages/{userId}/{partnerId}/{messageId}
///   - sender_id: string
///   - message_type: string
///   - timestamp: timestamp
///   - content: string ou map (dependendo do tipo)
/// 
/// Para chats de eventos:
/// - Messages/{userId}/event_{eventId}/{messageId}
///   - sender_id: string
///   - message_type: string
///   - timestamp: timestamp
///   - message: string

match /Messages/{userId} {
  match /{partnerId}/{messageId} {
    // Helper: verifica se √© chat de evento
    function isEventChat() {
      return partnerId.matches('event_.*');
    }
    
    // Helper: extrai eventId do partnerId (event_{eventId})
    function getEventId() {
      return partnerId.split('_')[1];
    }
    
    // Helper: verifica se usu√°rio √© participante aprovado do evento
    // Como EventApplications n√£o usa padr√£o de ID previs√≠vel, verificamos via query
    // Simplifica√ß√£o: assumimos que se o documento Messages/{userId}/event_{eventId} existe,
    // significa que o backend j√° validou e criou a conversa (via Cloud Function ap√≥s aprova√ß√£o)
    function isApprovedParticipant() {
      // Se chegou at√© aqui enviando mensagem, o backend j√° criou a conversa
      // Valida√ß√£o adicional seria custosa (query n√£o permitida em rules)
      return isSignedIn();
    }
    
    /// üìñ LEITURA:
    /// - Chat 1-1: usu√°rio pode ler suas pr√≥prias mensagens
    /// - Chat de evento: participante aprovado pode ler
    allow read: if isSignedIn() && (
      // Chat 1-1: sou o dono da conversa
      request.auth.uid == userId ||
      // Chat de evento: sou participante aprovado
      (isEventChat() && isApprovedParticipant())
    );
    
    /// ‚úçÔ∏è CRIAR mensagem:
    /// - Chat 1-1: participante pode enviar
    /// - Chat de evento: participante aprovado pode enviar
    allow create: if isSignedIn() && (
      // Chat 1-1
      (isParticipant(userId, partnerId) &&
       request.resource.data.sender_id == request.auth.uid &&
       request.resource.data.message_type is string &&
       request.resource.data.timestamp is timestamp) ||
      // Chat de evento
      (isEventChat() && 
       isApprovedParticipant() &&
       request.resource.data.sender_id == request.auth.uid &&
       request.resource.data.message_type is string &&
       request.resource.data.timestamp is timestamp)
    );
    
    /// ‚úèÔ∏è ATUALIZAR/DELETAR:
    /// - Apenas o dono da conversa pode atualizar/deletar
    allow update, delete: if isSignedIn() && request.auth.uid == userId;
  }
}

    // ======================================
    // üö´ Bloquear outras cole√ß√µes
    // ======================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
