/// üß© Firestore Security Rules - Arquitetura Modular
/// 
/// ‚ö†Ô∏è ARQUIVO GERADO AUTOMATICAMENTE
/// N√ÉO EDITE DIRETAMENTE - Edite os arquivos em /rules/ e execute ./build-rules.sh
/// 
/// Estrutura:
/// - rules/helpers.rules        ‚Üí Fun√ß√µes auxiliares reutiliz√°veis
/// - rules/users.rules          ‚Üí Cole√ß√£o Users/{userId}
/// - rules/app_config.rules     ‚Üí Cole√ß√£o AppInfo/{configName}
/// - rules/notifications.rules  ‚Üí Subcole√ß√£o Users/{userId}/Notifications/{notificationId}
/// - rules/device_tokens.rules  ‚Üí Cole√ß√£o DeviceTokens/{tokenId}
/// - rules/reviews.rules        ‚Üí Cole√ß√£o Reviews/{reviewId}
/// - rules/events.rules         ‚Üí Cole√ß√£o events/{eventId}
/// - rules/applications.rules   ‚Üí Cole√ß√£o EventApplications/{applicationId} [CORRIGIDO: permite leitura de aprovados]
/// - rules/event_chats.rules    ‚Üí Cole√ß√£o EventChats/{eventId} + subcole√ß√µes
/// - rules/connections.rules    ‚Üí Cole√ß√£o Connections/{userId}/Conversations/{withUserId}
/// - rules/messages.rules       ‚Üí Cole√ß√£o Messages/{userId}/{partnerId}/{messageId}
/// - rules/ranking.rules        ‚Üí Cole√ß√µes userRanking/{userId} e locationRanking/{placeId}
/// - rules/reports.rules        ‚Üí Cole√ß√£o reports/{reportId}

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ======================================
    // üîß Fun√ß√µes Auxiliares
    // ======================================
/// üîê Fun√ß√µes auxiliares de autentica√ß√£o/autoriza√ß√£o
/// Usadas em todos os arquivos de rules

function isSignedIn() {
  return request.auth != null;
}

function isOwner(userId) {
  return isSignedIn() && request.auth.uid == userId;
}

function isEventCreator(eventId) {
  return isSignedIn() && 
    get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid;
}

function isEventParticipant(eventId) {
  return isSignedIn() && 
    request.auth.uid in get(/databases/$(database)/documents/events/$(eventId)).data.participants.participantIds;
}

function isParticipant(u1, u2) {
  return isSignedIn() && (request.auth.uid == u1 || request.auth.uid == u2);
}

    // ======================================
    // üë§ Usu√°rios
    // ======================================
/// üë§ Cole√ß√£o principal de usu√°rios
/// Path usado no app:
/// - Users/{userId}
///   - fullName: string
///   - instagram: string
///   - jobTitle: string
///   - gender: string
///   - bio: string
///   - country: string
///   - originSource: string
///   - interests: array<string>
///   - agreeTerms: bool
///   - photoUrl: string
///   - createdAt: timestamp
///   - updatedAt: timestamp
///   - status: string ("active" | "blocked" | ...)
///   - isBlocked: bool

match /Users/{userId} {
  allow read: if isSignedIn();
  allow create, update, delete: if isOwner(userId);
  
  /// üëÅÔ∏è Subcole√ß√£o de visitas ao perfil (legacy - deprecada)
  /// Path: Users/{userId}/visits/{visitId}
  match /visits/{visitId} {
    allow read: if isOwner(userId);
    allow create, update: if isSignedIn();
    allow delete: if isOwner(userId);
  }
}

/// üë• Cole√ß√£o em min√∫sculo usada em algumas partes do app
/// Path usado no app:
/// - users/{userId}
///   (espelho simplificado de Users/{userId} para o m√≥dulo de perfil/cache)

match /users/{userId} {
  allow read: if isSignedIn();
  allow create, update, delete: if isOwner(userId);
  
  /// üëÅÔ∏è Subcole√ß√£o de visitas ao perfil (duplicada por compatibilidade)
  /// Path: users/{userId}/visits/{visitId}
  match /visits/{visitId} {
    allow read: if isOwner(userId);
    allow create, update: if isSignedIn();
    allow delete: if isOwner(userId);
  }
}

    // ======================================
    // ‚öôÔ∏è Configura√ß√µes da Aplica√ß√£o
    // ======================================
/// ‚öôÔ∏è Cole√ß√£o de configura√ß√µes da aplica√ß√£o
/// Path usado no app:
/// - AppInfo/{configName}
///   - GoogleAndroidMaps/Api_key: string
///   - GoogleMapsApiKey/Api_key: string

match /AppInfo/{configName} {
  allow read: if isSignedIn();
  allow write: if false; // Apenas leitura para usu√°rios
}

    // ======================================
    // üîî Notifica√ß√µes
    // ======================================
/// üîî Cole√ß√£o de notifica√ß√µes (root collection)
/// Path usado no app:
/// - Notifications/{notificationId}
///   - userId: string (quem recebe - campo principal)
///   - n_receiver_id: string (campo duplicado para compatibilidade - legacy)
///   - n_type: string
///   - n_sender_id: string
///   - n_sender_fullname: string
///   - n_sender_photo_url: string
///   - n_params: map
///   - n_metadata: map
///   - n_related_id: string
///   - n_read: bool
///   - timestamp: timestamp

match /Notifications/{notificationId} {
  // Permitir leitura se o usu√°rio √© o destinat√°rio (validar ambos os campos)
  allow read: if isSignedIn() && 
    (resource.data.userId == request.auth.uid || resource.data.n_receiver_id == request.auth.uid);
  
  // Permitir deletar apenas se for o destinat√°rio
  allow delete: if isSignedIn() && 
    (resource.data.userId == request.auth.uid || resource.data.n_receiver_id == request.auth.uid);
  
  // Qualquer usu√°rio logado pode criar/atualizar notifica√ß√µes
  allow create, update: if isSignedIn();
}

    // ======================================
    // üîë Tokens FCM
    // ======================================
/// üîë Cole√ß√£o de tokens FCM para push notifications
/// Path usado no app:
/// - DeviceTokens/{tokenId}
///   - userId: string (ID do usu√°rio dono do token)
///   - token: string (FCM token)
///   - deviceId: string (ID √∫nico do dispositivo)
///   - deviceName: string (nome do dispositivo)
///   - platform: string ("android" | "ios")
///   - createdAt: timestamp
///   - updatedAt: timestamp
///   - lastUsedAt: timestamp
///
/// Regras:
/// - Usu√°rio pode ler apenas seus pr√≥prios tokens
/// - Usu√°rio pode criar/atualizar apenas seus pr√≥prios tokens
/// - Usu√°rio pode deletar apenas seus pr√≥prios tokens
/// - Cloud Functions podem ler/escrever em qualquer token

match /DeviceTokens/{tokenId} {
  // Permite leitura apenas se for o dono do token
  allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
  
  // Permite cria√ß√£o/atualiza√ß√£o apenas se o userId no documento for o pr√≥prio usu√°rio
  allow create, update: if isSignedIn() && request.resource.data.userId == request.auth.uid;
  
  // Permite exclus√£o apenas se for o dono do token
  allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
}

    // ======================================
    // ‚≠ê Reviews/Avalia√ß√µes
    // ======================================
/// ‚≠ê Sistema completo de Reviews/Avalia√ß√µes
/// 
/// Collections:
/// - Reviews/{reviewId}           ‚Üí Reviews finalizadas
/// - PendingReviews/{pendingId}   ‚Üí Reviews pendentes (aguardando resposta)
/// - ReviewStats/{userId}         ‚Üí Estat√≠sticas agregadas por usu√°rio

// ============================================
// Reviews finalizadas
// ============================================
match /Reviews/{reviewId} {
  // Qualquer usu√°rio logado pode ler reviews
  allow read: if isSignedIn();
  
  // Criar review: apenas quem est√° fazendo a review (reviewerId)
  allow create: if isSignedIn() && 
    request.auth.uid == request.resource.data.reviewer_id;
  
  // Atualizar/deletar: apenas o autor da review
  allow update, delete: if isSignedIn() && 
    request.auth.uid == resource.data.reviewer_id;
}

// ============================================
// Reviews pendentes
// ============================================
match /PendingReviews/{pendingId} {
  // Ler: apenas o reviewer (quem deve fazer a review)
  allow read: if isSignedIn() && 
    request.auth.uid == resource.data.reviewer_id;
  
  // Criar: Cloud Functions OU Owner do evento criando review reverso para participante
  allow create: if isSignedIn() && (
    // Caso 1: Owner criando review REVERSO para participante avaliar o owner
    // O criador (request.auth.uid) deve ser o reviewee (quem ser√° avaliado = owner)
    // E o reviewer_role deve ser 'participant' (quem VAI fazer a review)
    (request.auth.uid == request.resource.data.reviewee_id &&
     request.resource.data.reviewer_role == 'participant') ||
    
    // Caso 2: Participante criando review para outro participante
    // (futuro - permitir avalia√ß√£o entre participantes)
    (request.auth.uid == request.resource.data.reviewer_id &&
     request.resource.data.reviewer_role == 'participant')
  );
  
  // Atualizar: apenas o reviewer pode:
  // 1. Marcar como dismissed
  // 2. Confirmar presen√ßa (para owners)
  allow update: if isSignedIn() && 
    request.auth.uid == resource.data.reviewer_id &&
    (
      // Op√ß√£o 1: dismissed
      (request.resource.data.dismissed == true &&
       request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly(['dismissed', 'dismissed_at'])) ||
      // Op√ß√£o 2: presence_confirmed (para owners)
      (request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly(['presence_confirmed', 'confirmed_participant_ids']))
    );
  
  // Deletar: Permitido se o usu√°rio for o reviewer (ao completar a review)
  allow delete: if isSignedIn() && 
    request.auth.uid == resource.data.reviewer_id;
}

// ============================================
// Estat√≠sticas agregadas
// ============================================
match /ReviewStats/{userId} {
  // Qualquer usu√°rio logado pode ler stats de outros
  allow read: if isSignedIn();
  
  // Criar/atualizar: qualquer usu√°rio autenticado pode atualizar stats
  // (necess√°rio para quando algu√©m faz uma review de outro usu√°rio)
  allow create, update: if isSignedIn();
  
  // Deletar: n√£o permitido
  allow delete: if false;
}

    // ======================================
    // üéâ Eventos
    // ======================================
/// üéâ Cole√ß√£o de eventos/atividades
/// Path usado no app:
/// - events/{eventId}
///   - activityText: string (descri√ß√£o da atividade)
///   - emoji: string
///   - createdBy: string (userId do criador)
///   - createdAt: timestamp
///   - updatedAt: timestamp
///   - location: map
///     - latitude: number
///     - longitude: number
///     - formattedAddress: string
///     - locationName: string
///     - locality: string
///     - placeId: string
///   - photoReferences: array<string> (opcional, fotos do Google Places)
///   - schedule: map
///     - date: timestamp
///     - timeType: string ("flexible" | "specific")
///     - specificTime: timestamp (opcional, quando timeType == "specific")
///   - participants: map
///     - minAge: number
///     - maxAge: number
///     - privacyType: string ("open" | "private")
///     - currentCount: number
///     - maxCount: number
///     - participantIds: array<string>
///     - pendingApprovalIds: array<string>
///   - status: string ("active" | "canceled" | "completed")
///   - isActive: bool
///   - isCanceled: bool
///   - expiresAt: timestamp

match /events/{eventId} {
  // Qualquer usu√°rio autenticado pode ler eventos ativos
  // Permite queries com where('isActive', isEqualTo: true)
  allow read: if isSignedIn();
  
  // Apenas usu√°rios autenticados podem criar eventos
  allow create: if isSignedIn() && 
    request.resource.data.createdBy == request.auth.uid &&
    request.resource.data.participants.participantIds[0] == request.auth.uid;
  
  // Apenas o criador pode atualizar ou deletar o evento
  allow update: if isSignedIn() && 
    resource.data.createdBy == request.auth.uid;
  
  allow delete: if isSignedIn() && 
    resource.data.createdBy == request.auth.uid;

  // Subcole√ß√£o: Participantes confirmados (para sistema de reviews)
  match /ConfirmedParticipants/{participantId} {
    // Helper para buscar o evento pai
    function getEvent() {
      return get(/databases/$(database)/documents/events/$(eventId)).data;
    }
    
    // Ler: criador do evento e o pr√≥prio participante
    allow read: if isSignedIn() && (
      request.auth.uid == getEvent().createdBy ||
      request.auth.uid == participantId
    );
    
    // Criar/Atualizar: apenas o criador do evento (durante confirma√ß√£o de presen√ßa no review)
    allow create, update: if isSignedIn() && 
      request.auth.uid == getEvent().createdBy;
    
    // Deletar: apenas o criador do evento
    allow delete: if isSignedIn() && 
      request.auth.uid == getEvent().createdBy;
  }
}

    // ======================================
    // üé´ Aplica√ß√µes para Eventos
    // ======================================
/// üé´ Cole√ß√£o de aplica√ß√µes para eventos
/// Path usado no app:
/// - EventApplications/{applicationId}
///   - eventId: string
///   - userId: string
///   - status: string ("pending" | "approved" | "rejected" | "autoApproved")
///   - appliedAt: timestamp
///   - decisionAt: timestamp (opcional)

match /EventApplications/{applicationId} {
  // Helper: buscar dados do evento relacionado
  function getEvent() {
    return get(/databases/$(database)/documents/events/$(resource.data.eventId)).data;
  }
  
  function getEventFromRequest() {
    return get(/databases/$(database)/documents/events/$(request.resource.data.eventId)).data;
  }
  
  /// üìñ LEITURA:
  /// - Criador do evento pode ver TODAS as aplica√ß√µes do seu evento
  /// - Usu√°rio pode ver APENAS suas pr√≥prias aplica√ß√µes
  /// - ‚≠ê QUALQUER usu√°rio autenticado pode ver aplica√ß√µes APROVADAS (para visualizar participantes no EventCard)
  allow read: if isSignedIn() && (
    // Sou o criador do evento
    request.auth.uid == getEvent().createdBy ||
    // √â minha pr√≥pria aplica√ß√£o
    request.auth.uid == resource.data.userId ||
    // √â uma aplica√ß√£o aprovada (qualquer um pode ver para visualizar participantes)
    (resource.data.status == 'approved' || resource.data.status == 'autoApproved')
  );
  
  /// ‚úçÔ∏è CRIAR aplica√ß√£o:
  /// - Usu√°rio autenticado
  /// - userId deve ser o pr√≥prio usu√°rio
  /// - Status deve ser "pending" ou "autoApproved" baseado no privacyType
  /// 
  /// ‚ö†Ô∏è NOTA: Prote√ß√£o contra duplicatas √© feita no app (event_application_repository.dart)
  /// pois Firestore Rules n√£o permite queries para verificar aplica√ß√µes existentes.
  /// A valida√ß√£o acontece antes de chamar .add() no reposit√≥rio.
  allow create: if isSignedIn() && 
    request.resource.data.userId == request.auth.uid &&
    request.resource.data.keys().hasAll(['eventId', 'userId', 'status', 'appliedAt']) &&
    (
      (getEventFromRequest().participants.privacyType == 'open' && 
       request.resource.data.status == 'autoApproved') ||
      (getEventFromRequest().participants.privacyType == 'private' && 
       request.resource.data.status == 'pending')
    );
  
  /// ‚úèÔ∏è ATUALIZAR aplica√ß√£o:
  /// CASO 1: Criador do evento aprovando/rejeitando
  /// - Apenas o criador do evento pode aprovar/rejeitar
  /// - N√£o pode mudar eventId ou userId
  /// - S√≥ pode mudar de "pending" para "approved" ou "rejected"
  /// - Deve incluir decisionAt
  allow update: if isSignedIn() && 
    request.auth.uid == getEvent().createdBy &&
    request.resource.data.eventId == resource.data.eventId &&
    request.resource.data.userId == resource.data.userId &&
    resource.data.status == 'pending' &&
    (request.resource.data.status == 'approved' || 
     request.resource.data.status == 'rejected') &&
    request.resource.data.decisionAt != null;
  
  /// ‚úèÔ∏è ATUALIZAR presen√ßa:
  /// CASO 2: Usu√°rio atualizando sua pr√≥pria presen√ßa
  /// - √â a pr√≥pria aplica√ß√£o do usu√°rio
  /// - S√≥ pode mudar o campo "presence"
  /// - N√£o pode mudar status, eventId ou userId
  /// - Aplica√ß√£o deve estar aprovada
  allow update: if isSignedIn() && 
    request.auth.uid == resource.data.userId &&
    request.resource.data.eventId == resource.data.eventId &&
    request.resource.data.userId == resource.data.userId &&
    request.resource.data.status == resource.data.status &&
    (resource.data.status == 'approved' || resource.data.status == 'autoApproved') &&
    request.resource.data.presence in ['Vou', 'Talvez', 'N√£o vou'];
  
  /// üóëÔ∏è DELETE: n√£o permitido
  allow delete: if false;
}

    // ======================================
    // üí¨ Chats de Eventos
    // ======================================
/// üí¨ Cole√ß√£o de chats de eventos (multiusu√°rio)
/// Path usado no app:
/// - EventChats/{eventId}
///   - eventId: string
///   - createdBy: string
///   - createdAt: timestamp
///   - lastMessage: string
///   - lastMessageAt: timestamp
///   - lastMessageSenderId: string
///   - participantIds: array<string>
///   - participantCount: number

match /EventChats/{eventId} {
  // Qualquer participante aprovado pode ler o chat
  allow read: if isSignedIn() && 
    request.auth.uid in resource.data.participantIds;
  
  // Apenas Cloud Functions podem criar/atualizar o documento principal
  allow write: if false;

  /// üí¨ Mensagens dentro do chat
  match /Messages/{messageId} {
    // Helper: verifica se usu√°rio √© participante do evento
    function isParticipant() {
      return request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds;
    }
    
    // Qualquer participante pode ler mensagens
    allow read: if isSignedIn() && isParticipant();
    
    // Qualquer participante pode criar mensagens (valida√ß√£o forte de sender_id)
    allow create: if isSignedIn() && 
      isParticipant() &&
      request.resource.data.sender_id == request.auth.uid &&
      request.resource.data.keys().hasAll(['sender_id', 'message_type', 'timestamp']);
    
    // N√£o pode editar/deletar mensagens
    allow update, delete: if false;
  }

  /// üë• Participantes do chat
  match /Participants/{userId} {
    // Cada participante pode ler todos os outros
    allow read: if isSignedIn() && 
      request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds;
    
    // Cada participante pode atualizar apenas seu pr√≥prio documento (lastReadAt, unreadCount)
    allow update: if isSignedIn() && 
      request.auth.uid == userId &&
      request.auth.uid in get(/databases/$(database)/documents/EventChats/$(eventId)).data.participantIds;
    
    // Apenas Cloud Functions podem criar/deletar participantes
    allow create, delete: if false;
  }
}

    // ======================================
    // üí¨ Connections (Conversas 1-1)
    // ======================================
/// üí¨ Cole√ß√£o de conex√µes/conversas entre usu√°rios e eventos
/// Path usado no app:
/// - Connections/{userId}/Conversations/{withUserId}
///   - user_id: string (userId do outro usu√°rio ou event_{eventId})
///   - fullname: string
///   - user_profile_photo: string
///   - message_type: string
///   - last_message: string
///   - message_read: bool
///   - timestamp: timestamp
///   - is_event_chat: bool (opcional, true para chats de eventos)
///   - event_id: string (opcional, eventId para chats de eventos)

match /Connections/{userId} {
  match /Conversations/{withUserId} {
    // Helper: verifica se √© conversa de evento
    function isEventConversation() {
      return withUserId.matches('event_.*');
    }
    
    // Helper: extrai eventId do withUserId (event_{eventId})
    function getEventId() {
      return withUserId.split('_')[1];
    }
    
    // Helper: verifica se usu√°rio √© participante aprovado do evento
    // Como EventApplications n√£o usa padr√£o de ID previs√≠vel, verificamos via query
    // Simplifica√ß√£o: assumimos que se o documento Connections/{userId}/Conversations/event_{eventId} existe,
    // significa que o backend j√° validou e criou a conversa (via Cloud Function ap√≥s aprova√ß√£o)
    function isApprovedParticipant() {
      // Se chegou at√© aqui, o backend j√° criou a conversa
      return isSignedIn();
    }
    
    /// üìñ LEITURA:
    /// - Conversa 1-1: usu√°rio pode ler suas pr√≥prias conversas
    /// - Conversa de evento: participante aprovado pode ler
    allow read: if isSignedIn() && (
      // Conversa 1-1: sou o dono
      request.auth.uid == userId ||
      // Conversa de evento: sou participante aprovado
      (isEventConversation() && request.auth.uid == userId && isApprovedParticipant())
    );
    
    /// ‚úçÔ∏è CRIAR/ATUALIZAR:
    /// - Conversa 1-1: ambos participantes podem criar/atualizar
    /// - Conversa de evento: participante aprovado pode criar/atualizar sua pr√≥pria conversa
    allow create, update: if isSignedIn() && (
      // Conversa 1-1: sou participante
      isParticipant(userId, withUserId) ||
      // Conversa de evento: sou o dono e sou participante aprovado
      (isEventConversation() && request.auth.uid == userId && isApprovedParticipant())
    );
    
    /// üóëÔ∏è DELETAR:
    /// - Apenas o dono pode deletar sua conversa
    allow delete: if isSignedIn() && request.auth.uid == userId;
  }
}

    // ======================================
    // üí¨ Messages (Mensagens 1-1)
    // ======================================
/// üí¨ Cole√ß√£o de mensagens entre usu√°rios e chats de eventos
/// Path usado no app:
/// - Messages/{userId}/{partnerId}/{messageId}
///   - sender_id: string
///   - message_type: string
///   - timestamp: timestamp
///   - content: string ou map (dependendo do tipo)
/// 
/// Para chats de eventos:
/// - Messages/{userId}/event_{eventId}/{messageId}
///   - sender_id: string
///   - message_type: string
///   - timestamp: timestamp
///   - message: string

match /Messages/{userId} {
  match /{partnerId}/{messageId} {
    // Helper: verifica se √© chat de evento
    function isEventChat() {
      return partnerId.matches('event_.*');
    }
    
    // Helper: extrai eventId do partnerId (event_{eventId})
    function getEventId() {
      return partnerId.split('_')[1];
    }
    
    // Helper: verifica se usu√°rio √© participante aprovado do evento
    // Como EventApplications n√£o usa padr√£o de ID previs√≠vel, verificamos via query
    // Simplifica√ß√£o: assumimos que se o documento Messages/{userId}/event_{eventId} existe,
    // significa que o backend j√° validou e criou a conversa (via Cloud Function ap√≥s aprova√ß√£o)
    function isApprovedParticipant() {
      // Se chegou at√© aqui enviando mensagem, o backend j√° criou a conversa
      // Valida√ß√£o adicional seria custosa (query n√£o permitida em rules)
      return isSignedIn();
    }
    
    /// üìñ LEITURA:
    /// - Chat 1-1: usu√°rio pode ler suas pr√≥prias mensagens
    /// - Chat de evento: participante aprovado pode ler
    allow read: if isSignedIn() && (
      // Chat 1-1: sou o dono da conversa
      request.auth.uid == userId ||
      // Chat de evento: sou participante aprovado
      (isEventChat() && isApprovedParticipant())
    );
    
    /// ‚úçÔ∏è CRIAR mensagem:
    /// - Chat 1-1: participante pode enviar
    /// - Chat de evento: participante aprovado pode enviar
    allow create: if isSignedIn() && (
      // Chat 1-1
      (isParticipant(userId, partnerId) &&
       request.resource.data.sender_id == request.auth.uid &&
       request.resource.data.message_type is string &&
       request.resource.data.timestamp is timestamp) ||
      // Chat de evento
      (isEventChat() && 
       isApprovedParticipant() &&
       request.resource.data.sender_id == request.auth.uid &&
       request.resource.data.message_type is string &&
       request.resource.data.timestamp is timestamp)
    );
    
    /// ‚úèÔ∏è ATUALIZAR/DELETAR:
    /// - Apenas o dono da conversa pode atualizar/deletar
    allow update, delete: if isSignedIn() && request.auth.uid == userId;
  }
}

    // ======================================
    // üëÅÔ∏è Visitas ao Perfil
    // ======================================
/// üëÅÔ∏è Cole√ß√£o de visitas ao perfil (root level para suporte TTL)
/// Path: ProfileVisits/{visitId}
/// 
/// Estrutura:
/// - visitedUserId: string (quem recebeu a visita)
/// - visitorId: string (quem visitou)
/// - visitedAt: timestamp
/// - visitCount: number (incrementa em visitas repetidas)
/// - expireAt: timestamp (TTL - 7 dias)
/// - source: string ('profile', 'event', etc)

match /ProfileVisits/{visitId} {
  // Qualquer usu√°rio autenticado pode ler suas pr√≥prias visitas
  allow read: if isSignedIn() && 
                 request.auth.uid == resource.data.visitedUserId;
  
  // Qualquer usu√°rio autenticado pode registrar visitas
  allow create, update: if isSignedIn();
  
  // Apenas o dono pode deletar suas visitas
  allow delete: if isSignedIn() && 
                   request.auth.uid == resource.data.visitedUserId;
}

/// üëÅÔ∏è Cole√ß√£o de views agregadas (para notifica√ß√µes)
/// Path: ProfileViews/{viewId}
match /ProfileViews/{viewId} {
  // Qualquer usu√°rio autenticado pode registrar views
  allow create: if isSignedIn();
  
  // Apenas o dono do perfil visualizado pode ler
  allow read: if isSignedIn() && 
                 request.auth.uid == resource.data.viewedUserId;
}

    // ======================================
    // üèÜ Rankings
    // ======================================
/// üèÜ Cole√ß√£o de ranking de usu√°rios
/// Path usado no app:
/// - userRanking/{userId}
///   - userId: string
///   - fullName: string
///   - photoUrl: string (nullable)
///   - totalEventsCreated: number
///   - lastEventAt: timestamp
///   - lastLat: number
///   - lastLng: number
///   - updatedAt: timestamp

match /userRanking/{userId} {
  // Qualquer usu√°rio autenticado pode ler rankings
  allow read: if isSignedIn();
  
  // Apenas Cloud Functions podem criar/atualizar rankings
  allow write: if false;
}

/// üèÜ Cole√ß√£o de ranking de locais
/// Path usado no app:
/// - locationRanking/{placeId}
///   - placeId: string
///   - locationName: string
///   - formattedAddress: string
///   - totalEventsHosted: number
///   - lastEventAt: timestamp
///   - lastLat: number
///   - lastLng: number
///   - updatedAt: timestamp

match /locationRanking/{placeId} {
  // Qualquer usu√°rio autenticado pode ler rankings
  allow read: if isSignedIn();
  
  // Apenas Cloud Functions podem criar/atualizar rankings
  allow write: if false;
}

    // ======================================
    // üö© Reports/Den√∫ncias
    // ======================================
/// üö© Regras de Seguran√ßa para Reports
/// 
/// Cole√ß√£o: reports/{reportId}
/// 
/// Caracter√≠sticas:
/// - Apenas usu√°rios autenticados podem criar reports
/// - Ningu√©m pode ler reports (apenas admins via console/backend)
/// - Mensagem limitada a 2000 caracteres
/// - Campos obrigat√≥rios validados

match /reports/{reportId} {
  // ‚ùå Ningu√©m pode ler reports (seguran√ßa e privacidade)
  allow read: if false;
  
  // ‚úÖ Apenas usu√°rios autenticados podem criar reports
  allow create: if isSignedIn()
    && request.resource.data.keys().hasAll([
      'reporterId', 'message', 'createdAt', 'platform', 'appVersion'
    ])
    && request.resource.data.reporterId == request.auth.uid
    && request.resource.data.message is string
    && request.resource.data.message.size() >= 10
    && request.resource.data.message.size() <= 2000
    && request.resource.data.platform is string
    && request.resource.data.appVersion is string;
  
  // ‚ùå Ningu√©m pode atualizar ou deletar reports
  allow update, delete: if false;
}

    // ======================================
    // üö´ Bloquear outras cole√ß√µes
    // ======================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
